<?php####################################################												#### Author:       Andrey Brykin (Drunya)         #### Version:      1.0                            #### Project:      CMS                            #### package       CMS Fapos                      #### subpackege    Watermark class                #### copyright     ©Andrey Brykin 2010-2011       ########################################################################################################												#### any partial or not partial extension         #### CMS Fapos,without the consent of the         #### author, is illegal                           ###################################################### Любое распространение                        #### CMS Fapos или ее частей,                     #### без согласия автора, является не законным    ####################################################class FpsImg {	private $imgTypes = array(		1 => 'GIF',		2 => 'JPEG',		3 => 'PNG',	);	public function createWaterMark($orig, $watermark, $position = 'bottom', $alpha_level = 100) {		if (!file_exists($orig) || !file_exists($watermark)) return false;				if (function_exists('exif_imagetype')) {			$orig_type = exif_imagetype($orig);			$water_type = exif_imagetype($watermark);		} else if (function_exists('getimagesize')) {			$orig_type = getimagesize($orig);			$water_type = getimagesize($watermark);			$orig_type = $orig_type['mime'];			$water_type = $water_type['mime'];		} else {			return false;		}				if (empty($orig_type) || empty($water_type)) return false;		if ($orig_type === 1 || $orig_type === 'image/gif') $main_img_obj = imagecreatefromgif($orig);		else if ($orig_type === 2 || $orig_type === 'image/jpeg') $main_img_obj = imagecreatefromjpeg($orig);		else if ($orig_type === 3 || $orig_type === 'image/png') $main_img_obj = imagecreatefrompng($orig);				if ($water_type === 1 || $water_type === 'image/gif') $watermark_img_obj = imagecreatefromgif($watermark);		else if ($water_type === 2 || $water_type === 'image/jpeg') $watermark_img_obj = imagecreatefromjpeg($watermark);		else if ($water_type === 3 || $water_type === 'image/png') $watermark_img_obj = imagecreatefrompng($watermark);		if (empty($main_img_obj) || empty($watermark_img_obj)) return false;		$alpha_level/= 100; 		// get sizes		$main_img_obj_w = imagesx($main_img_obj);		$main_img_obj_h = imagesy($main_img_obj);		$watermark_img_obj_w = imagesx($watermark_img_obj);		$watermark_img_obj_h = imagesy($watermark_img_obj);		// Center of image		$main_img_obj_min_x = floor(($main_img_obj_w - $watermark_img_obj_w) - 10);		$main_img_obj_max_x = ceil(($main_img_obj_w + $watermark_img_obj_w) - 10);		$main_img_obj_min_y = floor(($main_img_obj_h - $watermark_img_obj_h) - 10);		$main_img_obj_max_y = ceil(($main_img_obj_h + $watermark_img_obj_h) - 10); 		// create image		$return_img = imagecreatetruecolor($main_img_obj_w, $main_img_obj_h);		// Each pixel		for($y = 1; $y < $main_img_obj_h; $y++) { 			for ($x = 1; $x < $main_img_obj_w; $x++) { 				$return_color = NULL;				// pixel position				$watermark_x = $x - $main_img_obj_min_x;				$watermark_y = $y - $main_img_obj_min_y;				// Get color info				$main_rgb = imagecolorsforindex($main_img_obj, imagecolorat($main_img_obj, $x, $y));							# если наш пиксель водяного знака непрозрачный 				if ($watermark_x >= 0 && $watermark_x < $watermark_img_obj_w 				&& $watermark_y >= 0 && $watermark_y < $watermark_img_obj_h) 				{ 					$watermark_rbg = imagecolorsforindex($watermark_img_obj						, imagecolorat($watermark_img_obj,						   $watermark_x,						   $watermark_y));					// Alpha chanel					$watermark_alpha = round(((127-$watermark_rbg['alpha'])/127),2);					$watermark_alpha = $watermark_alpha * $alpha_level;										// Get color in overlay place					$avg_red = $this->__get_ave_color( $main_rgb['red'],							   $watermark_rbg['red'], $watermark_alpha );					$avg_green = $this->__get_ave_color( $main_rgb['green'],								 $watermark_rbg['green'], $watermark_alpha );					$avg_blue = $this->__get_ave_color( $main_rgb['blue'],								$watermark_rbg['blue'], $watermark_alpha );											// Index of color					$return_color = $this->__get_image_color($return_img, $avg_red, $avg_green, $avg_blue);				} else { 					// Or get copy of pixel					$return_color = imagecolorat( $main_img_obj, $x, $y ); 					$color_tren = imagecolorsforindex($main_img_obj, $return_color);					$r = $color_tren['red'];					$g = $color_tren['green'];					$b = $color_tren['blue'];					$alpha = $color_tren['alpha'];					$return_color = $this->__get_image_color($return_img, $r, $g, $b);				} 						//pr($return_color); die();				// Create new image with new pixels				imagesetpixel($return_img, $x, $y, $return_color );			}		} 				//header("Content-Type: image/jpeg");		// View image		switch ($orig_type) {			case 1:			case 'image/gif':				imagegif($return_img, $orig);				break;			case 2:			case 'image/jpeg':				imagejpeg($return_img, $orig);				break;			case 3:			case 'image/png':				imagepng($return_img, $orig);				break;			default:				imagejpeg($return_img, $orig);				break;		}						imagedestroy($return_img);		imagedestroy($main_img_obj);		imagedestroy($watermark_img_obj);	}			/**	 * merge 2 colors with alpha chanel	 */	private function __get_ave_color($color_a, $color_b, $alpha_level) { 		return round((($color_a*(1-$alpha_level))+($color_b*$alpha_level))); 	} 			/**	 * return RGB color	 */	private function __get_image_color($im, $r, $g, $b) { 		$c = imagecolorexact($im, $r, $g, $b);		if ($c != -1) return $c;		$c = imagecolorallocate($im, $r, $g, $b);		if ($c != -1) return $c;		return imagecolorclosest($im, $r, $g, $b);	} }?>